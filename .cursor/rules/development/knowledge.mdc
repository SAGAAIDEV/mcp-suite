---
description: 
globs: 
alwaysApply: false
---
## Node Types

### File
Represents source code and test files in the codebase.

**Properties:**
- `path`: The file's full path
- `module_path`: The file's module path relative to the project
- `name`: The filename
- `isTest`: Boolean flag for test files


### Function
Represents a function in the codebase.

**Properties:**
- `name`: Function name
- `signature`: Full function signature
- `returnType`: Return type
- `docstring`: Function documentation

### Class
Represents a class in the codebase.

**Properties:**
- `name`: Class name
- `docstring`: Class documentation

### Method
Represents a method within a class.

**Properties:**
- `name`: Method name
- `signature`: Full method signature
- `returnType`: Return type
- `docstring`: Method documentation
- `isStatic`: Boolean flag for static methods

### Variable
Represents a variable in the codebase.

**Properties:**
- `name`: Variable name
- `type`: Variable type
- `scope`: Scope (global, local, class)

### TestCase
Represents a test function or method.

**Properties:**
- `name`: Test name
- `testType`: Type of test (unit, integration, etc.)

## Relationship Types

### CONTAINS
Connects containers to their contents.

**Direction:** File → Function/Class/Variable, Class → Method/Variable

**Properties:**
- `visibility`: Public, private, protected

### IMPORTS
Connects files that import other files.

**Direction:** File → File

**Properties:**
- `importType`: Direct, relative, aliased
- `alias`: Name if imported with alias

### CALLS
Connects functions/methods that call other functions/methods.

**Direction:** Function → Function, Method → Method, Function → Method, Method → Function

**Properties:**
- `callCount`: Number of times called
- `parameters`: Parameters passed
- `explanation`: The reason the caller function calls the called function.

### INHERITS_FROM
Connects classes that inherit from other classes.

**Direction:** Class → Class

**Properties:**
- `inheritanceType`: Single, multiple
- `explanation`: The reason the class inherits from the parent.

### TESTS
Connects tests to the code they test.

**Direction:** TestCase → Function/Method/Class

**Properties:**
- `coverageModule`: The module of that the test should cover.

### HAS_TEST
The inverse of TESTS, connects code to its tests.

**Direction:** File → File (Production file to Test file), Function/Method/Class → TestCase

**Properties:**
- `coverage`: Coverage percentage
- `lastVerified`: Timestamp of last verification

### DEPENDS_ON
Connects code to variables it depends on.

**Direction:** Function/Method → Variable

**Properties:**
- `dependencyType`: Read, write, both

### REFERENCES
General-purpose relationship for any reference between nodes.

**Direction:** Any node → Any node

**Properties:**
- `referenceType`: Direct, indirect

### IMPLEMENTS
Connects classes to interfaces they implement.

**Direction:** Class → Interface (for languages with interfaces)

## Example Queries

### Find all test cases for a specific function
```cypher
MATCH (f:Function {name: 'validate_file_path'})-[:HAS_TEST]->(t:TestCase)
RETURN f.name as function, collect(t.name) as testCases
```

### Find all functions a function calls (dependencies)
```cypher
MATCH (f:Function {name: 'validate_file_path'})-[:CALLS]->(dependency:Function)
RETURN f.name as function, collect(dependency.name) as dependencies
```

### Find files without tests
```cypher
MATCH (f:File)
WHERE f.isTest = false AND NOT (f)-[:HAS_TEST]->()
RETURN f.name as filesWithoutTests
```

### Find test coverage information
```cypher
MATCH (source)-[testRel:TESTS]->(target)
RETURN 
    CASE 
        WHEN source:File THEN 'File' 
        WHEN source:TestCase THEN 'TestCase' 
    END as sourceType,
    source.name as source,
    CASE 
        WHEN target:File THEN 'File' 
        WHEN target:Function THEN 'Function'
    END as targetType,
    target.name as target,
    testRel.testCoverage as coveragePercentage
```

### Find all import relationships
```cypher
MATCH (source:File)-[importRel:IMPORTS]->(target:File)
RETURN source.name as sourceFile, target.name as importedFile, importRel.importType as importType
```

## Implementation

To implement this knowledge graph:

1. Parse the codebase to extract entities and relationships
2. Store them in Neo4j using the schema above
3. Write queries to extract useful information
4. Visualize the relationships to understand the codebase structure

## Benefits

- Complete code traceability
- Test coverage insights
- Impact analysis for code changes
- Documentation enhancement
- Code quality metrics
- Identification of:
  - Dead code
  - Tightly coupled components
  - Test gaps
  - Module dependencies
  - Data flow

## Example Code

The following Cypher query creates a simple knowledge graph for a validation module and its tests:

```cypher
// Create Files
CREATE (validation:File {path: 'src/mcp_suite/servers/qa/tools/testing/lib/validation.py', name: 'validation.py', type: 'Python', isTest: false})
CREATE (testValidation:File {path: 'src/tests/unit/test_servers/test_qa/test_tools/test_testing/test_lib/test_validation.py', name: 'test_validation.py', type: 'Python', isTest: true})
CREATE (files:File {path: 'src/mcp_suite/servers/qa/utils/files.py', name: 'files.py', type: 'Python', isTest: false})

// Create Functions in validation.py
CREATE (validateFilePath:Function {name: 'validate_file_path', signature: 'validate_file_path(file_path: str, tool_function) -> ToolResult', returnType: 'ToolResult', lineStart: 22, lineEnd: 55, docstring: 'Validate that the provided file path is a valid Python file.'})
CREATE (validateCoverageModule:Function {name: 'validate_coverage_module', signature: 'validate_coverage_module(coverage_module: str, tool_function) -> ToolResult', returnType: 'ToolResult', lineStart: 58, lineEnd: 101, docstring: 'Validate that the provided coverage module exists and can be imported.'})

// Create Functions in files.py
CREATE (isValidPythonPath:Function {name: 'is_valid_python_path', signature: 'is_valid_python_path(path: str) -> bool', returnType: 'bool', lineStart: 4, lineEnd: 38, docstring: 'Check if a path is a valid Python file.'})

// Create Test cases
CREATE (testValidFilePath:TestCase {name: 'test_valid_file_path', lineStart: 15, lineEnd: 28, testType: 'unit'})
CREATE (testInvalidPythonPathFormat:TestCase {name: 'test_invalid_python_path_format', lineStart: 30, lineEnd: 45, testType: 'unit'})
CREATE (testNonexistentFilePath:TestCase {name: 'test_nonexistent_file_path', lineStart: 47, lineEnd: 71, testType: 'unit'})
CREATE (testDotDirectoryPath:TestCase {name: 'test_dot_directory_path', lineStart: 73, lineEnd: 85, testType: 'unit'})

// Connect Files to Functions
CREATE (validation)-[:CONTAINS {visibility: 'public'}]->(validateFilePath)
CREATE (validation)-[:CONTAINS {visibility: 'public'}]->(validateCoverageModule)
CREATE (files)-[:CONTAINS {visibility: 'public'}]->(isValidPythonPath)

// Connect Test File to Test Cases
CREATE (testValidation)-[:CONTAINS {visibility: 'public'}]->(testValidFilePath)
CREATE (testValidation)-[:CONTAINS {visibility: 'public'}]->(testInvalidPythonPathFormat)
CREATE (testValidation)-[:CONTAINS {visibility: 'public'}]->(testNonexistentFilePath)
CREATE (testValidation)-[:CONTAINS {visibility: 'public'}]->(testDotDirectoryPath)

// File Imports
CREATE (validation)-[:IMPORTS {importType: 'direct'}]->(files)

// Function Calls
CREATE (validateFilePath)-[:CALLS {callCount: 1, lineNumbers: [35], explanation: 'Validates that the file path follows Python module format'}]->(isValidPythonPath)

// Test Relationships
CREATE (testValidation)-[:TESTS {testCoverage: 100, coverageModule: 'mcp_suite.servers.qa.tools.testing.lib.validation'}]->(validation)
CREATE (testValidFilePath)-[:TESTS {testCoverage: 25, coverageModule: 'mcp_suite.servers.qa.tools.testing.lib.validation'}]->(validateFilePath)
CREATE (testInvalidPythonPathFormat)-[:TESTS {testCoverage: 25, coverageModule: 'mcp_suite.servers.qa.tools.testing.lib.validation'}]->(validateFilePath)
CREATE (testNonexistentFilePath)-[:TESTS {testCoverage: 25, coverageModule: 'mcp_suite.servers.qa.tools.testing.lib.validation'}]->(validateFilePath)
CREATE (testDotDirectoryPath)-[:TESTS {testCoverage: 25, coverageModule: 'mcp_suite.servers.qa.tools.testing.lib.validation'}]->(validateFilePath)

// HAS_TEST Relationships
CREATE (validation)-[:HAS_TEST {coverage: 100, lastVerified: datetime()}]->(testValidation)
CREATE (validateFilePath)-[:HAS_TEST {coverage: 100, lastVerified: datetime()}]->(testValidFilePath)
CREATE (validateFilePath)-[:HAS_TEST {coverage: 100, lastVerified: datetime()}]->(testInvalidPythonPathFormat)
CREATE (validateFilePath)-[:HAS_TEST {coverage: 100, lastVerified: datetime()}]->(testNonexistentFilePath)
CREATE (validateFilePath)-[:HAS_TEST {coverage: 100, lastVerified: datetime()}]->(testDotDirectoryPath)
``` 

## Additional Example Queries

### Find functions that call a specific function
```cypher
MATCH (caller)-[callRel:CALLS]->(callee:Function {name: 'is_valid_python_path'})
RETURN 
    CASE 
        WHEN caller:Function THEN 'Function' 
        WHEN caller:Method THEN 'Method' 
    END as callerType,
    caller.name as caller,
    callRel.callCount as callCount,
    callRel.explanation as reason
```

### Find classes and their inheritance relationships
```cypher
MATCH (child:Class)-[inherits:INHERITS_FROM]->(parent:Class)
RETURN 
    child.name as childClass,
    parent.name as parentClass,
    inherits.inheritanceType as inheritanceType,
    inherits.explanation as reason
```

### Find all dependencies between functions and variables
```cypher
MATCH (f)-[depends:DEPENDS_ON]->(v:Variable)
RETURN 
    CASE 
        WHEN f:Function THEN 'Function' 
        WHEN f:Method THEN 'Method' 
    END as dependentType,
    f.name as dependent,
    v.name as variable,
    v.type as variableType,
    depends.dependencyType as accessType
```

### Find test coverage gaps in the codebase
```cypher
MATCH (f:Function)
WHERE NOT (f)-[:HAS_TEST]->() OR 
      ANY(rel IN [(f)-[test:HAS_TEST]->() | test] WHERE rel.coverage < 80)
RETURN f.name as functionWithLowCoverage,
       f.path as filePath,
       CASE 
           WHEN NOT (f)-[:HAS_TEST]->() THEN 0
           ELSE [(f)-[test:HAS_TEST]->() | test.coverage][0]
       END as coveragePercentage
```

### Find code impact for a specific change
```cypher
// Find all code that would be affected by changes to a specific function
MATCH path = (:Function {name: 'is_valid_python_path'})<-[:CALLS*1..3]-()
WITH DISTINCT nodes(path) as impactedNodes
UNWIND impactedNodes as node
RETURN 
    CASE 
        WHEN node:Function THEN 'Function' 
        WHEN node:Method THEN 'Method' 
        WHEN node:Class THEN 'Class'
    END as nodeType,
    node.name as name,
    [(test:TestCase)-[:TESTS]->(node) | test.name] as relatedTests
```

### Find references between components
```cypher
MATCH (source)-[ref:REFERENCES]->(target)
WHERE ref.referenceType = 'Direct'
RETURN 
    CASE 
        WHEN source:Function THEN 'Function' 
        WHEN source:Class THEN 'Class'
        WHEN source:Variable THEN 'Variable'
        ELSE 'Other'
    END as sourceType,
    source.name as source,
    CASE 
        WHEN target:Function THEN 'Function' 
        WHEN target:Class THEN 'Class'
        WHEN target:Variable THEN 'Variable'
        ELSE 'Other'
    END as targetType,
    target.name as target
```

### Find classes that implement specific interfaces
```cypher
MATCH (class:Class)-[impl:IMPLEMENTS]->(interface)
RETURN 
    class.name as implementingClass,
    interface.name as interfaceName
``` 
