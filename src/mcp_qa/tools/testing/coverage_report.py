"""
Coverage tool for the SaagaLint MCP server.

This module provides a tool for analyzing code coverage and identifying
areas of code that are not covered by tests. It integrates with the MCP
server to provide a unified interface for coverage analysis.

Features:
- Analyze coverage reports generated by pytest
- Identify files and functions with low coverage
- Provide helpful instructions for improving coverage
- Generate detailed reports for specific files
"""

from pathlib import Path

from mcp_qa.config import logger
from mcp_qa.config.constants import ReportPaths
from mcp_qa.models.tool_result import (
    NextAction,
    ToolResult,
    ToolStatus,
)
from mcp_qa.tools.testing.lib.coverage import process_coverage_json
from mcp_qa.utils.decorators import exception_handler


@exception_handler()
async def run_coverage(file_path: str):
    """
    Analyze code coverage for a specific file.

    This function reads the coverage report generated by pytest and
    analyzes it to identify areas of code that are not covered by tests.

    Args:
        file_path: Path to the file to analyze, relative to the git root.
                  If None, analyzes the entire project.

    Returns:
        ToolResult: A ToolResult object containing coverage results and instructions
    """
    try:
        logger.info(f"Analyzing code coverage for {file_path}")

        # Process coverage data
        coverage_file = ReportPaths.COVERAGE.value
        logger.debug(f"Coverage file: {coverage_file}")

        if not Path(coverage_file).exists():
            logger.error(f"Coverage file does not exist: {coverage_file}")
            return ToolResult(
                status=ToolStatus.FAILURE,
                message="Coverage report not found. "
                "Please run tests first to generate coverage data.",
            )

        logger.info("Processing coverage data")
        try:
            coverage_issues = process_coverage_json(str(coverage_file), file_path)
        except Exception as e:
            logger.error(f"Error processing coverage data: {str(e)}", exc_info=True)
            return ToolResult(
                status=ToolStatus.FAILURE,
                message=f"Error processing coverage data: {str(e)}",
            )

        # If no issues found, return success
        if not coverage_issues:
            logger.info("No coverage issues found")
            return ToolResult(
                status=ToolStatus.SUCCESS,
                message=(
                    "Great job! No coverage issues found. "
                    "Your code has excellent test coverage. Keep up the good work!"
                ),
            )

        # Return the first issue to fix
        logger.warning(f"Found {len(coverage_issues)} coverage issues")
        logger.debug(f"First issue: {coverage_issues[0]}")

        # Create next action to call coverage tool again after fixing this issue
        next_action = NextAction(
            tool=run_coverage,
            instructions=(
                "After fixing this coverage issue, run the coverage tool again "
                "to check for additional issues."
            ),
            # kwargs={"file_path": file_path},
        )

        result = ToolResult(
            status=ToolStatus.FAILURE,
            message=(
                "Let's improve your test coverage! I've identified an area of code "
                "that isn't covered by tests. Let's work together to write tests "
                "for this area to ensure your code is robust and reliable."
                f"\n\nIssue: {coverage_issues[0]}"
            ),
            next_action=next_action,
        )
        logger.info(f"Returning result: {result}")
        return result
    except Exception as e:
        logger.error(f"Error in run_coverage: {str(e)}", exc_info=True)
        return ToolResult(
            status=ToolStatus.FAILURE, message=f"Error analyzing coverage: {str(e)}"
        )


@exception_handler()
async def next_coverage_issue():
    """
    Fixes next coverage issue

    This function reads the coverage report and returns the first file found.
    If no files are present, it returns a success message.

    Returns:
        ToolResult: A ToolResult object containing the result and next actions.
    """
    try:
        # ReportPaths.COVERAGE is already a Path object
        coverage_file: Path = ReportPaths.COVERAGE.value
        logger.info(f"Coverage file path: {coverage_file}")

        if not Path(coverage_file).exists():
            result = ToolResult(
                status=ToolStatus.FAILURE,
                message="Coverage report not found. "
                "Please run tests first to generate coverage data.",
            )
            logger.info(f"Returning result: {result}")
            return result
        coverage_issues = process_coverage_json(str(coverage_file))
        # filter for next coverage issue get a file

        first_issue = next(iter(coverage_issues), None)
        if first_issue:

            # Create next action to run coverage tool on this file

            result = ToolResult(
                status=ToolStatus.FAILURE,
                message=(f"1. Fix : {first_issue}.", "Run pytest mcp tool again"),
            )
            logger.info(f"Returning result: {result}")
            return result
        else:
            result = ToolResult(
                status=ToolStatus.SUCCESS,
                message="All coverage issues are solved.",
            )
            logger.info(f"Returning result: {result}")
            return result
    except Exception as e:
        logger.error(f"Error processing coverage file: {str(e)}", exc_info=True)
        result = ToolResult(
            status=ToolStatus.FAILURE,
            message=f"Error processing coverage report: {str(e)}. "
            f"Please run tests using the mcp tool run_pytest on src/",
        )
        logger.info(f"Returning error result: {result}")
        return result
