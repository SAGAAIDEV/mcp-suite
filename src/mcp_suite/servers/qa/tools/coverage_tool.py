"""
Coverage tool for the SaagaLint MCP server.

This module provides a tool for analyzing code coverage and identifying
areas of code that are not covered by tests. It integrates with the MCP
server to provide a unified interface for coverage analysis.

Features:
- Analyze coverage reports generated by pytest
- Identify files and functions with low coverage
- Provide helpful instructions for improving coverage
- Generate detailed reports for specific files
"""

import json

from mcp_suite.servers.qa import logger as main_logger
from mcp_suite.servers.qa.service.coverage import process_coverage_json
from mcp_suite.servers.qa.utils.decorators import exception_handler
from mcp_suite.servers.qa.utils.git_utils import get_git_root
from mcp_suite.servers.qa.utils.logging_utils import get_component_logger

# Get a component-specific logger
logger = get_component_logger("coverage")


@exception_handler()
async def run_coverage(file_path):
    """
    Analyze code coverage for a specific file or the entire project.

    This function reads the coverage report generated by pytest and
    analyzes it to identify areas of code that are not covered by tests.

    Args:
        file_path: Path to the file to analyze, relative to the git root.
                  If None, analyzes the entire project.

    Returns:
        dict: A dictionary containing coverage results and instructions
    """
    logger.info(f"Running coverage analysis for: {file_path}")
    main_logger.info(f"Running coverage analysis for: {file_path}")

    coverage_results_file = get_git_root() / "reports/coverage.json"
    logger.debug(f"Reading coverage results from: {coverage_results_file}")

    result = process_coverage_json(coverage_results_file)

    # Log each coverage issue for debugging
    logger.info(f"Found {len(result)} coverage issues")
    for issue in result:
        issue_data = issue.model_dump()
        logger.debug(f"Coverage issue details: {json.dumps(issue_data, indent=2)}")

    if file_path:
        logger.info(f"Filtering results for file: {file_path}")
        result = next((item for item in result if item.file_path == file_path), None)
    else:
        result = str(result.values()[0])

    if result:
        issue_count = len(result) if hasattr(result, "__len__") else 1
        logger.warning(f"Coverage issues found: {issue_count} issues")
        main_logger.warning(f"Coverage issues found: {issue_count} issues")

        return {
            "Message": str(result),
            "Instructions": (
                "We're making great progress! Let's improve the test coverage "
                "for these areas. I'll help you understand what needs to be tested "
                "and how to write effective tests for the missing coverage. "
                "Once you've added the tests, run the pytest tool again. "
                "Remember, better test coverage means more reliable code!"
            ),
        }
    else:
        logger.info("Coverage is complete!")
        main_logger.info("Coverage analysis complete - no issues found")

        return {
            "Message": (
                "Outstanding job! Your test coverage is complete and comprehensive. "
                "You're doing excellent work!"
            ),
            "Instructions": (
                "You're on a roll! Let's continue with running the linting tools "
                "to make sure your code style is as perfect as your test coverage. "
                "Keep up the great work!"
            ),
        }
